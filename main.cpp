/*

Реализация класса для представления матриц

В этой лабораторной работе требуется реализовать класс для представления вещественных матриц и выполнения операций с ними.
Класс должен хранить матрицу типа double в виде одномерноого массива или массива массивов.

Требования к API

Конструкторы и деструктор
Mat(int m, int n) - создаёт матрицу указанных размеров.
Mat(std::vector<double> vec) - создаёт матрицу размера vec.size() x 1и заполняет её элементами вектора.
Mat(const double* mem, int m) - создаёт матрицу размеров m x 1, заполняя её данными из массива.
Mat(const Mat& other) - создаёт матрицу тех же размеров, что и b и копирует в неё данные из other.
Созданная матрица и матрица other должны иметь одинаковые размеры и значения, и использовать различные указатели для хранения данных.
Mat() - создаёт пустую матрицу размера 0 x 0.
~Mat() - освобождает память, выделенную под матрицу, если она не пустая.

Методы
std::pair<int, int> size() const - возвращает размеры матрицы.
const double& get(int i, int j) - возвращает ссылку на элемент с индексами i, j. Индексация элементов начинается с 0.
double* data(int i) - возвращает указатель на начало i-ой строки.
norm() - возвращает Фробениосову норму матрицы.
uniform_() - заполняет матрицу случайными числами, равномерно распределёнными в дапазаоне [0;1].

Перегруженные операторы
Mat& operator=(const Mat& other) - оператор присваивания. Копирует матрицу other в текущую и возвращает ссылку на текущую матрицу.
Процедура копирования та же, что в конструкторе копирования, только здесть потребуется сначала освободить память текущей матрицы,
если её размеры не совпадают с other, а затем выделить память подходящего размера и скопировать в неё данные.
std::ostream& operator<<(std::ostream& os, const Mat& obj) - вывод матрицы в поток. Возввращается ссылка не этот же поток.
bool operator==(const Mat& lhs, const Mat& rhs) - оператор, проверяющий поэлементное равенство матриц.
bool operator!=(const Mat& lhs, const Mat& rhs) - отрицание предыдущего оператора.
Mat operator+(const Mat& lhs, const Mat& rhs) - сложение матриц.
Mat operator-(const Mat& lhs, const Mat& rhs) - вычитание матриц.
Mat operator*(const Mat& lhs, const Mat& rhs) - умножение матриц.
Mat operator*(const Mat& lhs, const double alpha) - умножение матрицы на константу.

Примечания:
- Все бинарные операторы должны возвращать новую матрицу, которая является результатом выполнения бинароной операции.
- Вместо std::pair<int, int> можно использовать свою структуру для представления размера.
Также в C++ 11 есть возможность сделать алиас для типа и использовать тип по новому инени: using Size = std::pair<int, int>;
- Релизация класса должна быть отделена от его декларации, т.е. должно быть два файла: .hpp для декларации и .cpp для реализации.
- В случае, если совершить какую-либо операцию невозможно (например, размеры матриц для сложения разные),
соответствующий оператор должен генерировать исключение.
- Конструкторы также должны генерировать исключение в случае некорректных входных данных.

Дополнительные требования
- Сделать класс матриц шаблонным. Допустимый параметр шаблона - любой числовой тип C++.
- Реализовать функцию для решения уравнений вида A*x=b, где x, b - векторы-столюбы, A - невырожденная квадратная матрица.
Прототип: Mat<T> solve (const Mat<T>& A, const Mat<T>& b). Функция должна возвращать x, если решение существует или
пустую матрицу в противном случае. Стоит обратить внимание, что решить уравнение в общем случае возможно только над
полем вещественных чисел, и это надо предусмотреть. Для этого можно использовать механизм проверки типов на этапе компиляции.

*/
#include <iostream>

using namespace std;


#include "Mat.hpp"
#include "TMat.hpp"

int main()
{
    lab::Mat a(2, 4);
    a.uniform_();
    cout << "mat A:\n" << a << "\n\n";
    cout << "mat A == A:\n" << (a == a) << "\n\n";
    cout << "mat A != A:\n" << (a != a) << "\n\n";
    cout << "mat A + A:\n" << (a + a) << "\n\n";
    cout << "mat A - A:\n" << (a - a) << "\n\n";
    cout << "mat A * 2.0:\n" << (a * 2.0) << "\n\n";
    
    lab::Mat b(4, 3);
    b.uniform_();
    cout << "mat B:\n" << b << "\n\n";
    
    lab::Mat c(a * b);
    cout << "mat C:\n" << c << "\n\n";
    
    lab::Mat mat1;
    lab::Mat mat2(mat1);
    lab::Mat mat3;
    mat3 = mat2;
    
    cout << "mat Vec:\n" << lab::Mat({1.0, 2.0, 3.0, 4.0, 5.0}) << "\n\n";
    
    double arr[] = {1.0, 2.0, 3.0};
    cout << "mat Arr:\n" << lab::Mat(arr, 3) << "\n\n";
    
    cout << "mat Mat(5,5):\n" << lab::Mat(5, 5) << "\n\n";
    
    lab::TMat<double> m1(4,4);
    m1.uniform_();
    cout << "m1:\n" << m1 << endl;
    lab::TMat<double> m2(4,1);
    m2.uniform_();
    cout << "m2:\n" << m2 << endl;
    
    cout << "m3 = \n" << solve(m1, m2) << endl;
    
    lab::Mat _mat;
    lab::Mat _mat1 (_mat);
    lab::Mat _mat2;
    _mat2 = _mat;
    
    return 0;
}